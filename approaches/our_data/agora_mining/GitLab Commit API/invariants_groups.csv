endpoint,group,invariant,invariantType,variables,postmanAssertion,pptname
get+projects,_links.self,"return._links.self is a substring of return._links.issues
return._links.self is a substring of return._links.merge_requests
return._links.self is a substring of return._links.repo_branches
return._links.self is a substring of return._links.labels
return._links.self is a substring of return._links.events
return._links.self is a substring of return._links.members","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return._links.self, return._links.issues)
(return._links.self, return._links.merge_requests)
(return._links.self, return._links.repo_branches)
(return._links.self, return._links.labels)
(return._links.self, return._links.events)
(return._links.self, return._links.members)","pm.expect(return__links_issues.includes(return__links_self)).to.be.true
pm.expect(return__links_merge_requests.includes(return__links_self)).to.be.true
pm.expect(return__links_repo_branches.includes(return__links_self)).to.be.true
pm.expect(return__links_labels.includes(return__links_self)).to.be.true
pm.expect(return__links_events.includes(return__links_self)).to.be.true
pm.expect(return__links_members.includes(return__links_self)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,archived,input.archived == return.archived,daikon.inv.binary.twoScalar.IntEqual,"(input.archived, return.archived)",pm.expect(input_archived).to.eql(return_archived),/projects&/projects&get&200():::EXIT
get+projects,auto_devops_deploy_strategy,"return.auto_devops_deploy_strategy one of { ""continuous"", ""manual"", ""timed_incremental"" }",daikon.inv.unary.string.OneOfString,(return.auto_devops_deploy_strategy),"pm.expect([""continuous"", ""manual"", ""timed_incremental""].includes(return_auto_devops_deploy_strategy)).to.be.true",/projects&/projects&get&200():::EXIT
get+projects,avatar_url,return.avatar_url is Url,daikon.inv.unary.string.IsUrl,(return.avatar_url),"pm.expect(return_avatar_url).to.match(/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[\w\u00a1-\uffff0-9]+-?)*[\w\u00a1-\uffff0-9]+)(?:\.(?:[\w\u00a1-\uffff0-9]+-)*[\w\u00a1-\uffff0-9]+)*(?:\.(?:[a-zA-Z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/)",/projects&/projects&get&200():::EXIT
get+projects,created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,creator_id,return.creator_id >= 1,daikon.inv.unary.scalar.LowerBound,(return.creator_id),pm.expect(return_creator_id).to.be.at.least(1),/projects&/projects&get&200():::EXIT
get+projects,default_branch,return.default_branch is a substring of return.readme_url,daikon.inv.binary.twoString.StdString$SubString,"(return.default_branch, return.readme_url)",pm.expect(return_readme_url.includes(return_default_branch)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,external_authorization_classification_label,"return.external_authorization_classification_label == """"
LENGTH(return.external_authorization_classification_label)==0","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.external_authorization_classification_label)
(return.external_authorization_classification_label)","pm.expect([""""].includes(return_external_authorization_classification_label)).to.be.true
pm.expect(return_external_authorization_classification_label).to.have.length(0)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,forks_count,return.forks_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.forks_count),pm.expect(return_forks_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,http_url_to_repo,return.web_url is a substring of return.http_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.http_url_to_repo, return.web_url)",pm.expect(return_http_url_to_repo.includes(return_web_url)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,id,"input.id_after < return.id
input.id_before > return.id
return.id > return.star_count
return.id > size(return.tag_list[])","daikon.inv.binary.twoScalar.IntLessThan
daikon.inv.binary.twoScalar.IntGreaterThan
daikon.inv.binary.twoScalar.IntGreaterThan
daikon.inv.binary.twoScalar.IntGreaterThan","(input.id_after, return.id)
(input.id_before, return.id)
(return.id, return.star_count)
(return.id, size(return.tag_list[..]))","pm.expect(input_id_after).to.be.lessThan(return_id)
pm.expect(input_id_before).to.be.greaterThan(return_id)
pm.expect(return_id).to.be.greaterThan(return_star_count)
pm.expect(return_id).to.be.greaterThan(return_tag_list_size_array)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,last_activity_at,"LENGTH(return.last_activity_at)==24
return.last_activity_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.last_activity_at)
(return.last_activity_at)","pm.expect(return_last_activity_at).to.have.length(24)
pm.expect(return_last_activity_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,merge_method,"return.merge_method one of { ""ff"", ""merge"", ""rebase_merge"" }",daikon.inv.unary.string.OneOfString,(return.merge_method),"pm.expect([""ff"", ""merge"", ""rebase_merge""].includes(return_merge_method)).to.be.true",/projects&/projects&get&200():::EXIT
get+projects,name,return.name is a substring of return.name_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.name, return.name_with_namespace)",pm.expect(return_name_with_namespace.includes(return_name)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,name_with_namespace,return.namespace.name is a substring of return.name_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.name_with_namespace, return.namespace.name)",pm.expect(return_name_with_namespace.includes(return_namespace_name)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,namespace.id,return.namespace.id >= 1,daikon.inv.unary.scalar.LowerBound,(return.namespace.id),pm.expect(return_namespace_id).to.be.at.least(1),/projects&/projects&get&200():::EXIT
get+projects,namespace.kind,"return.namespace.kind one of { ""group"", ""user"" }",daikon.inv.unary.string.OneOfString,(return.namespace.kind),"pm.expect([""group"", ""user""].includes(return_namespace_kind)).to.be.true",/projects&/projects&get&200():::EXIT
get+projects,namespace.path,return.namespace.path is a substring of return.namespace.full_path,daikon.inv.binary.twoString.StdString$SubString,"(return.namespace.path, return.namespace.full_path)",pm.expect(return_namespace_full_path.includes(return_namespace_path)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,open_issues_count,return.open_issues_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.open_issues_count),pm.expect(return_open_issues_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,owner.id,return.owner.id >= 1,daikon.inv.unary.scalar.LowerBound,(return.owner.id),pm.expect(return_owner_id).to.be.at.least(1),/projects&/projects&get&200():::EXIT
get+projects,owner.name,"return.owner.name == return.namespace.name
return.owner.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(return.owner.name, return.namespace.name)
(return.owner.name, return.name_with_namespace)","pm.expect(return_owner_name).to.eql(return_namespace_name)
pm.expect(return_name_with_namespace.includes(return_owner_name)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,path,return.path is a substring of return.path_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.path, return.path_with_namespace)",pm.expect(return_path_with_namespace.includes(return_path)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,path_with_namespace,return.namespace.full_path is a substring of return.path_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.path_with_namespace, return.namespace.full_path)",pm.expect(return_path_with_namespace.includes(return_namespace_full_path)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,permissions.group_access.notification_level,return.permissions.group_access.notification_level == 3,daikon.inv.unary.scalar.OneOfScalar,(return.permissions.group_access.notification_level),pm.expect([3].includes(return_permissions_group_access_notification_level)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,permissions.project_access.access_level,return.permissions.project_access.access_level == return.permissions.group_access.access_level,daikon.inv.binary.twoScalar.IntEqual,"(return.permissions.project_access.access_level, return.permissions.group_access.access_level)",pm.expect(return_permissions_project_access_access_level).to.eql(return_permissions_group_access_access_level),/projects&/projects&get&200():::EXIT
get+projects,permissions.project_access.notification_level,"return.permissions.project_access.notification_level == return.permissions.group_access.notification_level
return.permissions.project_access.notification_level == 3","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.OneOfScalar","(return.permissions.project_access.notification_level, return.permissions.group_access.notification_level)
(return.permissions.project_access.notification_level)","pm.expect(return_permissions_project_access_notification_level).to.eql(return_permissions_group_access_notification_level)
pm.expect([3].includes(return_permissions_project_access_notification_level)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,repository_storage,"return.repository_storage == ""default""
LENGTH(return.repository_storage)==7","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.repository_storage)
(return.repository_storage)","pm.expect([""default""].includes(return_repository_storage)).to.be.true
pm.expect(return_repository_storage).to.have.length(7)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,runners_token,LENGTH(return.runners_token)==29,daikon.inv.unary.string.FixedLengthString,(return.runners_token),pm.expect(return_runners_token).to.have.length(29),/projects&/projects&get&200():::EXIT
get+projects,ssh_url_to_repo,return.path_with_namespace is a substring of return.ssh_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.ssh_url_to_repo, return.path_with_namespace)",pm.expect(return_ssh_url_to_repo.includes(return_path_with_namespace)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,star_count,return.star_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.star_count),pm.expect(return_star_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,statistics.commit_count,return.statistics.commit_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.statistics.commit_count),pm.expect(return_statistics_commit_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,statistics.repository_size,"return.statistics.repository_size >= 0
return.statistics.repository_size >= return.statistics.lfs_objects_size","daikon.inv.unary.scalar.LowerBound
daikon.inv.binary.twoScalar.IntGreaterEqual","(return.statistics.repository_size)
(return.statistics.repository_size, return.statistics.lfs_objects_size)","pm.expect(return_statistics_repository_size).to.be.at.least(0)
pm.expect(return_statistics_repository_size).to.be.at.least(return_statistics_lfs_objects_size)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,statistics.storage_size,"return.statistics.storage_size >= 0
return.statistics.storage_size >= return.statistics.repository_size
return.statistics.storage_size >= return.statistics.wiki_size
return.statistics.storage_size >= return.statistics.lfs_objects_size","daikon.inv.unary.scalar.LowerBound
daikon.inv.binary.twoScalar.IntGreaterEqual
daikon.inv.binary.twoScalar.IntGreaterEqual
daikon.inv.binary.twoScalar.IntGreaterEqual","(return.statistics.storage_size)
(return.statistics.storage_size, return.statistics.repository_size)
(return.statistics.storage_size, return.statistics.wiki_size)
(return.statistics.storage_size, return.statistics.lfs_objects_size)","pm.expect(return_statistics_storage_size).to.be.at.least(0)
pm.expect(return_statistics_storage_size).to.be.at.least(return_statistics_repository_size)
pm.expect(return_statistics_storage_size).to.be.at.least(return_statistics_wiki_size)
pm.expect(return_statistics_storage_size).to.be.at.least(return_statistics_lfs_objects_size)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,visibility,"input.visibility == return.visibility
return.visibility one of { ""internal"", ""private"", ""public"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.visibility, return.visibility)
(return.visibility)","pm.expect(input_visibility).to.eql(return_visibility)
pm.expect([""internal"", ""private"", ""public""].includes(return_visibility)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,web_url,"return.web_url is a substring of return.readme_url
return.path_with_namespace is a substring of return.web_url","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return.web_url, return.readme_url)
(return.web_url, return.path_with_namespace)","pm.expect(return_readme_url.includes(return_web_url)).to.be.true
pm.expect(return_web_url.includes(return_path_with_namespace)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects_{id}_repository_commits,array,size(return.array[]) == 20,daikon.inv.unary.scalar.OneOfScalar,(size(return.array[..])),pm.expect([20].includes(return_array_size_array)).to.be.true,/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200%array():::EXIT
get+projects_{id}_repository_commits,authored_date,"LENGTH(return.authored_date)==29
return.authored_date is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.authored_date)
(return.authored_date)","pm.expect(return_authored_date).to.have.length(29)
pm.expect(return_authored_date).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT"
get+projects_{id}_repository_commits,created_at,"LENGTH(return.created_at)==29
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(29)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT"
get+projects_{id}_repository_commits,id,"LENGTH(return.id)==40
return.short_id is a substring of return.id","daikon.inv.unary.string.FixedLengthString
daikon.inv.binary.twoString.StdString$SubString","(return.id)
(return.id, return.short_id)","pm.expect(return_id).to.have.length(40)
pm.expect(return_id.includes(return_short_id)).to.be.true","/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT"
get+projects_{id}_repository_commits,message,return.title is a substring of return.message,daikon.inv.binary.twoString.StdString$SubString,"(return.message, return.title)",pm.expect(return_message.includes(return_title)).to.be.true,/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT
get+projects_{id}_repository_commits,parent_ids,"All the elements of return.parent_ids[] have LENGTH=40
size(return.parent_ids[]) one of { 1, 2 }","daikon.inv.unary.stringsequence.SequenceFixedLengthString
daikon.inv.unary.scalar.OneOfScalar","(return.parent_ids[..])
(size(return.parent_ids[..]))","pm.expect(return_parent_ids_array.every(element => element.length === 40)).to.be.true
pm.expect([1, 2, 0].includes(return_parent_ids_size_array)).to.be.true","/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT"
get+projects_{id}_repository_commits,short_id,LENGTH(return.short_id)==8,daikon.inv.unary.string.FixedLengthString,(return.short_id),pm.expect(return_short_id).to.have.length(8),/projects/{id}/repository/commits&/projects/{id}/repository/commits&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_comments,author.avatar_url,"LENGTH(return.author.avatar_url)==113
return.author.avatar_url is Url","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.IsUrl","(return.author.avatar_url)
(return.author.avatar_url)","pm.expect(return_author_avatar_url).to.have.length(113)
pm.expect(return_author_avatar_url).to.match(/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[\w\u00a1-\uffff0-9]+-?)*[\w\u00a1-\uffff0-9]+)(?:\.(?:[\w\u00a1-\uffff0-9]+-)*[\w\u00a1-\uffff0-9]+)*(?:\.(?:[a-zA-Z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/)","/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_comments,author.id,return.author.id >= 1,daikon.inv.unary.scalar.LowerBound,(return.author.id),pm.expect(return_author_id).to.be.at.least(1),/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_comments,author.state,"return.author.state == ""active""
LENGTH(return.author.state)==6","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.author.state)
(return.author.state)","pm.expect([""active""].includes(return_author_state)).to.be.true
pm.expect(return_author_state).to.have.length(6)","/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_comments,author.web_url,return.author.username is a substring of return.author.web_url,daikon.inv.binary.twoString.StdString$SubString,"(return.author.web_url, return.author.username)",pm.expect(return_author_web_url.includes(return_author_username)).to.be.true,/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_comments,created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/comments&/projects/{id}/repository/commits/{sha}/comments&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,author.state,"return.author.state one of { ""active"", ""blocked"" }",daikon.inv.unary.string.OneOfString,(return.author.state),"pm.expect([""active"", ""blocked""].includes(return_author_state)).to.be.true",/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,author.web_url,return.author.username is a substring of return.author.web_url,daikon.inv.binary.twoString.StdString$SubString,"(return.author.web_url, return.author.username)",pm.expect(return_author_web_url.includes(return_author_username)).to.be.true,/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,discussion_locked,"return.discussion_locked == ""true""
LENGTH(return.discussion_locked)==4","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.discussion_locked)
(return.discussion_locked)","pm.expect([""true""].includes(return_discussion_locked)).to.be.true
pm.expect(return_discussion_locked).to.have.length(4)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,downvotes,"return.downvotes == return.time_stats.total_time_spent
return.downvotes == 0
return.downvotes <= return.user_notes_count
return.downvotes <= return.time_stats.time_estimate
return.downvotes <= size(return.labels[])","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.OneOfScalar
daikon.inv.binary.twoScalar.IntLessEqual
daikon.inv.binary.twoScalar.IntLessEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.downvotes, return.time_stats.total_time_spent)
(return.downvotes)
(return.downvotes, return.user_notes_count)
(return.downvotes, return.time_stats.time_estimate)
(return.downvotes, size(return.labels[..]))","pm.expect(return_downvotes).to.eql(return_time_stats_total_time_spent)
pm.expect([0].includes(return_downvotes)).to.be.true
pm.expect(return_downvotes).to.be.lte(return_user_notes_count)
pm.expect(return_downvotes).to.be.lte(return_time_stats_time_estimate)
pm.expect(return_downvotes).to.be.lte(return_labels_size_array)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,id,"return.id > return.project_id
return.id > return.author.id
return.id > return.source_project_id","daikon.inv.binary.twoScalar.IntGreaterThan
daikon.inv.binary.twoScalar.IntGreaterThan
daikon.inv.binary.twoScalar.IntGreaterThan","(return.id, return.project_id)
(return.id, return.author.id)
(return.id, return.source_project_id)","pm.expect(return_id).to.be.greaterThan(return_project_id)
pm.expect(return_id).to.be.greaterThan(return_author_id)
pm.expect(return_id).to.be.greaterThan(return_source_project_id)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,iid,"return.iid < return.author.id
return.iid > size(return.labels[])","daikon.inv.binary.twoScalar.IntLessThan
daikon.inv.binary.twoScalar.IntGreaterThan","(return.iid, return.author.id)
(return.iid, size(return.labels[..]))","pm.expect(return_iid).to.be.lessThan(return_author_id)
pm.expect(return_iid).to.be.greaterThan(return_labels_size_array)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,merge_commit_sha,LENGTH(return.merge_commit_sha)==40,daikon.inv.unary.string.FixedLengthString,(return.merge_commit_sha),pm.expect(return_merge_commit_sha).to.have.length(40),/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,merge_status,"return.merge_status one of { ""can_be_merged"", ""cannot_be_merged"", ""cannot_be_merged_recheck"" }",daikon.inv.unary.string.OneOfString,(return.merge_status),"pm.expect([""can_be_merged"", ""cannot_be_merged"", ""cannot_be_merged_recheck""].includes(return_merge_status)).to.be.true",/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,merge_when_pipeline_succeeds,"return.merge_when_pipeline_succeeds one of { 0, 1 }",daikon.inv.unary.scalar.OneOfScalar,(return.merge_when_pipeline_succeeds),"pm.expect([0, 1, 0].includes(return_merge_when_pipeline_succeeds)).to.be.true",/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,project_id,"return.project_id == return.target_project_id
return.project_id <= return.source_project_id","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.project_id, return.target_project_id)
(return.project_id, return.source_project_id)","pm.expect(return_project_id).to.eql(return_target_project_id)
pm.expect(return_project_id).to.be.lte(return_source_project_id)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,sha,LENGTH(return.sha)==40,daikon.inv.unary.string.FixedLengthString,(return.sha),pm.expect(return_sha).to.have.length(40),/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,should_remove_source_branch,"return.should_remove_source_branch one of { ""false"", ""true"" }",daikon.inv.unary.string.OneOfString,(return.should_remove_source_branch),"pm.expect([""false"", ""true""].includes(return_should_remove_source_branch)).to.be.true",/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,squash_commit_sha,LENGTH(return.squash_commit_sha)==40,daikon.inv.unary.string.FixedLengthString,(return.squash_commit_sha),pm.expect(return_squash_commit_sha).to.have.length(40),/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,state,"return.state one of { ""closed"", ""merged"", ""opened"" }
LENGTH(return.state)==6","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.state)
(return.state)","pm.expect([""closed"", ""merged"", ""opened""].includes(return_state)).to.be.true
pm.expect(return_state).to.have.length(6)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,time_stats.human_time_estimate,"return.time_stats.human_time_estimate == ""16h""",daikon.inv.unary.string.OneOfString,(return.time_stats.human_time_estimate),"pm.expect([""16h""].includes(return_time_stats_human_time_estimate)).to.be.true",/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,time_stats.time_estimate,"return.time_stats.time_estimate one of { 0, 57600 }",daikon.inv.unary.scalar.OneOfScalar,(return.time_stats.time_estimate),"pm.expect([0, 57600, 0].includes(return_time_stats_time_estimate)).to.be.true",/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_merge_requests,updated_at,"LENGTH(return.updated_at)==24
return.updated_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.updated_at)
(return.updated_at)","pm.expect(return_updated_at).to.have.length(24)
pm.expect(return_updated_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,upvotes,"return.upvotes one of { 0, 1, 2 }
return.upvotes >= return.downvotes","daikon.inv.unary.scalar.OneOfScalar
daikon.inv.binary.twoScalar.IntGreaterEqual","(return.upvotes)
(return.upvotes, return.downvotes)","pm.expect([0, 1, 2].includes(return_upvotes)).to.be.true
pm.expect(return_upvotes).to.be.at.least(return_downvotes)","/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_merge_requests,user_notes_count,return.user_notes_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.user_notes_count),pm.expect(return_user_notes_count).to.be.at.least(0),/projects/{id}/repository/commits/{sha}/merge_requests&/projects/{id}/repository/commits/{sha}/merge_requests&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_refs,type,"return.type one of { ""branch"", ""tag"" }",daikon.inv.unary.string.OneOfString,(return.type),"pm.expect([""branch"", ""tag""].includes(return_type)).to.be.true",/projects/{id}/repository/commits/{sha}/refs&/projects/{id}/repository/commits/{sha}/refs&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_signature,commit_source,"return.commit_source == ""gitaly""
LENGTH(return.commit_source)==6","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.commit_source)
(return.commit_source)","pm.expect([""gitaly""].includes(return_commit_source)).to.be.true
pm.expect(return_commit_source).to.have.length(6)","/projects/{id}/repository/commits/{sha}/signature&/projects/{id}/repository/commits/{sha}/signature&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/signature&/projects/{id}/repository/commits/{sha}/signature&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_signature,signature_type,LENGTH(return.signature_type)==3,daikon.inv.unary.string.FixedLengthString,(return.signature_type),pm.expect(return_signature_type).to.have.length(3),/projects/{id}/repository/commits/{sha}/signature&/projects/{id}/repository/commits/{sha}/signature&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_signature,verification_status,"return.verification_status == ""unknown_key""
LENGTH(return.verification_status)==11","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.verification_status)
(return.verification_status)","pm.expect([""unknown_key""].includes(return_verification_status)).to.be.true
pm.expect(return_verification_status).to.have.length(11)","/projects/{id}/repository/commits/{sha}/signature&/projects/{id}/repository/commits/{sha}/signature&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/signature&/projects/{id}/repository/commits/{sha}/signature&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_signature,x509_certificate,return.x509_certificate == null,daikon.inv.unary.scalar.OneOfScalar,(return.x509_certificate),pm.expect(return_x509_certificate).to.be.null,/projects/{id}/repository/commits/{sha}/signature&/projects/{id}/repository/commits/{sha}/signature&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_signature,x509_certificate.x509_issuer,return.x509_certificate.x509_issuer == null,daikon.inv.unary.scalar.OneOfScalar,(return.x509_certificate.x509_issuer),pm.expect(return_x509_certificate_x509_issuer).to.be.null,/projects/{id}/repository/commits/{sha}/signature&/projects/{id}/repository/commits/{sha}/signature&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_statuses,array,input.per_page >= size(return.array[]),daikon.inv.binary.twoScalar.IntGreaterEqual,"(input.per_page, size(return.array[..]))",pm.expect(input_per_page).to.be.at.least(return_array_size_array),/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200%array():::EXIT
get+projects_{id}_repository_commits_{sha}_statuses,author.avatar_url,"LENGTH(return.author.avatar_url)==113
return.author.avatar_url is Url","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.IsUrl","(return.author.avatar_url)
(return.author.avatar_url)","pm.expect(return_author_avatar_url).to.have.length(113)
pm.expect(return_author_avatar_url).to.match(/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[\w\u00a1-\uffff0-9]+-?)*[\w\u00a1-\uffff0-9]+)(?:\.(?:[\w\u00a1-\uffff0-9]+-)*[\w\u00a1-\uffff0-9]+)*(?:\.(?:[a-zA-Z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/)","/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_statuses,author.id,return.author.id >= 1,daikon.inv.unary.scalar.LowerBound,(return.author.id),pm.expect(return_author_id).to.be.at.least(1),/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_statuses,author.state,"return.author.state == ""active""
LENGTH(return.author.state)==6","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.author.state)
(return.author.state)","pm.expect([""active""].includes(return_author_state)).to.be.true
pm.expect(return_author_state).to.have.length(6)","/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_statuses,author.web_url,return.author.username is a substring of return.author.web_url,daikon.inv.binary.twoString.StdString$SubString,"(return.author.web_url, return.author.username)",pm.expect(return_author_web_url.includes(return_author_username)).to.be.true,/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_statuses,coverage,return.coverage is Numeric,daikon.inv.unary.string.IsNumeric,(return.coverage),"pm.expect(return_coverage).to.match(/^[+-]{0,1}(0|([0-9](\d*|\d{0,2}(,\d{3})*)))?(\.\d*[0-9])?$/)",/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_statuses,created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_statuses,finished_at,"LENGTH(return.finished_at)==24
return.finished_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.finished_at)
(return.finished_at)","pm.expect(return_finished_at).to.have.length(24)
pm.expect(return_finished_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT"
get+projects_{id}_repository_commits_{sha}_statuses,id,return.id is Numeric,daikon.inv.unary.string.IsNumeric,(return.id),"pm.expect(return_id).to.match(/^[+-]{0,1}(0|([0-9](\d*|\d{0,2}(,\d{3})*)))?(\.\d*[0-9])?$/)",/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_statuses,sha,input.sha == return.sha,daikon.inv.binary.twoString.StringEqual,"(input.sha, return.sha)",pm.expect(input_sha).to.eql(return_sha),/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
get+projects_{id}_repository_commits_{sha}_statuses,started_at,"LENGTH(return.started_at)==24
return.started_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.started_at)
(return.started_at)","pm.expect(return_started_at).to.have.length(24)
pm.expect(return_started_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT
/projects/{id}/repository/commits/{sha}/statuses&/projects/{id}/repository/commits/{sha}/statuses&get&200():::EXIT"
post+projects,_links.self,"return._links.self is a substring of return._links.issues
return._links.self is a substring of return._links.merge_requests
return._links.self is a substring of return._links.repo_branches
return._links.self is a substring of return._links.labels
return._links.self is a substring of return._links.events
return._links.self is a substring of return._links.members","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return._links.self, return._links.issues)
(return._links.self, return._links.merge_requests)
(return._links.self, return._links.repo_branches)
(return._links.self, return._links.labels)
(return._links.self, return._links.events)
(return._links.self, return._links.members)","pm.expect(return__links_issues.includes(return__links_self)).to.be.true
pm.expect(return__links_merge_requests.includes(return__links_self)).to.be.true
pm.expect(return__links_repo_branches.includes(return__links_self)).to.be.true
pm.expect(return__links_labels.includes(return__links_self)).to.be.true
pm.expect(return__links_events.includes(return__links_self)).to.be.true
pm.expect(return__links_members.includes(return__links_self)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,allow_merge_on_skipped_pipeline,input.allow_merge_on_skipped_pipeline == return.allow_merge_on_skipped_pipeline,daikon.inv.binary.twoScalar.IntEqual,"(input.allow_merge_on_skipped_pipeline, return.allow_merge_on_skipped_pipeline)",pm.expect(input_allow_merge_on_skipped_pipeline).to.eql(return_allow_merge_on_skipped_pipeline),/projects&/projects&post&201():::EXIT
post+projects,archived,"return.archived == return.service_desk_enabled
return.archived == false","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.OneOfScalar","(return.archived, return.service_desk_enabled)
(return.archived)","pm.expect(return_archived).to.eql(return_service_desk_enabled)
pm.expect(return_archived).to.eql(false)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,auto_devops_deploy_strategy,"input.auto_devops_deploy_strategy == return.auto_devops_deploy_strategy
return.auto_devops_deploy_strategy one of { ""continuous"", ""manual"", ""timed_incremental"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.auto_devops_deploy_strategy, return.auto_devops_deploy_strategy)
(return.auto_devops_deploy_strategy)","pm.expect(input_auto_devops_deploy_strategy).to.eql(return_auto_devops_deploy_strategy)
pm.expect([""continuous"", ""manual"", ""timed_incremental""].includes(return_auto_devops_deploy_strategy)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,auto_devops_enabled,input.auto_devops_enabled == return.auto_devops_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.auto_devops_enabled, return.auto_devops_enabled)",pm.expect(input_auto_devops_enabled).to.eql(return_auto_devops_enabled),/projects&/projects&post&201():::EXIT
post+projects,autoclose_referenced_issues,input.autoclose_referenced_issues == return.autoclose_referenced_issues,daikon.inv.binary.twoScalar.IntEqual,"(input.autoclose_referenced_issues, return.autoclose_referenced_issues)",pm.expect(input_autoclose_referenced_issues).to.eql(return_autoclose_referenced_issues),/projects&/projects&post&201():::EXIT
post+projects,ci_default_git_depth,return.ci_default_git_depth == 20,daikon.inv.unary.scalar.OneOfScalar,(return.ci_default_git_depth),pm.expect([20].includes(return_ci_default_git_depth)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,ci_forward_deployment_enabled,return.ci_forward_deployment_enabled == true,daikon.inv.unary.scalar.OneOfScalar,(return.ci_forward_deployment_enabled),pm.expect(return_ci_forward_deployment_enabled).to.eql(true),/projects&/projects&post&201():::EXIT
post+projects,container_registry_enabled,input.container_registry_enabled == return.container_registry_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.container_registry_enabled, return.container_registry_enabled)",pm.expect(input_container_registry_enabled).to.eql(return_container_registry_enabled),/projects&/projects&post&201():::EXIT
post+projects,created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,creator_id,return.creator_id <= return.namespace.id,daikon.inv.binary.twoScalar.IntLessEqual,"(return.creator_id, return.namespace.id)",pm.expect(return_creator_id).to.be.lte(return_namespace_id),/projects&/projects&post&201():::EXIT
post+projects,default_branch,return.default_branch is a substring of return.readme_url,daikon.inv.binary.twoString.StdString$SubString,"(return.default_branch, return.readme_url)",pm.expect(return_readme_url.includes(return_default_branch)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,description,input.description == return.description,daikon.inv.binary.twoString.StringEqual,"(input.description, return.description)",pm.expect(input_description).to.eql(return_description),/projects&/projects&post&201():::EXIT
post+projects,forks_count,"return.forks_count == return.star_count
return.forks_count == size(return.shared_with_groups[])
return.forks_count == size(return.shared_with_groups[])
return.forks_count <= size(return.tag_list[])","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.forks_count, return.star_count)
(return.forks_count, size(return.shared_with_groups[..]))
(return.forks_count, size(return.shared_with_groups[..]))
(return.forks_count, size(return.tag_list[..]))","pm.expect(return_forks_count).to.eql(return_star_count)
pm.expect(return_forks_count).to.eql(return_shared_with_groups_size_array)
pm.expect(return_forks_count).to.eql(return_shared_with_groups_size_array)
pm.expect(return_forks_count).to.be.lte(return_tag_list_size_array)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,http_url_to_repo,return.web_url is a substring of return.http_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.http_url_to_repo, return.web_url)",pm.expect(return_http_url_to_repo.includes(return_web_url)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,import_status,"return.import_status == ""none""
LENGTH(return.import_status)==4","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.import_status)
(return.import_status)","pm.expect([""none""].includes(return_import_status)).to.be.true
pm.expect(return_import_status).to.have.length(4)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,last_activity_at,"LENGTH(return.last_activity_at)==24
return.last_activity_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.last_activity_at)
(return.last_activity_at)","pm.expect(return_last_activity_at).to.have.length(24)
pm.expect(return_last_activity_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,merge_method,"input.merge_method == return.merge_method
return.merge_method one of { ""ff"", ""merge"", ""rebase_merge"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.merge_method, return.merge_method)
(return.merge_method)","pm.expect(input_merge_method).to.eql(return_merge_method)
pm.expect([""ff"", ""merge"", ""rebase_merge""].includes(return_merge_method)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,name,"input.name == return.name
return.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(input.name, return.name)
(return.name, return.name_with_namespace)","pm.expect(input_name).to.eql(return_name)
pm.expect(return_name_with_namespace.includes(return_name)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,name_with_namespace,"input.name is a substring of return.name_with_namespace
return.namespace.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(input.name, return.name_with_namespace)
(return.name_with_namespace, return.namespace.name)","pm.expect(return_name_with_namespace.includes(input_name)).to.be.true
pm.expect(return_name_with_namespace.includes(return_namespace_name)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,namespace.id,"input.namespace_id == return.namespace.id
return.namespace.id >= 1","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.LowerBound","(input.namespace_id, return.namespace.id)
(return.namespace.id)","pm.expect(input_namespace_id).to.eql(return_namespace_id)
pm.expect(return_namespace_id).to.be.at.least(1)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,namespace.kind,"return.namespace.kind one of { ""group"", ""user"" }",daikon.inv.unary.string.OneOfString,(return.namespace.kind),"pm.expect([""group"", ""user""].includes(return_namespace_kind)).to.be.true",/projects&/projects&post&201():::EXIT
post+projects,namespace.path,return.namespace.path is a substring of return.namespace.full_path,daikon.inv.binary.twoString.StdString$SubString,"(return.namespace.path, return.namespace.full_path)",pm.expect(return_namespace_full_path.includes(return_namespace_path)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,only_allow_merge_if_all_discussions_are_resolved,input.only_allow_merge_if_all_discussions_are_resolved == return.only_allow_merge_if_all_discussions_are_resolved,daikon.inv.binary.twoScalar.IntEqual,"(input.only_allow_merge_if_all_discussions_are_resolved, return.only_allow_merge_if_all_discussions_are_resolved)",pm.expect(input_only_allow_merge_if_all_discussions_are_resolved).to.eql(return_only_allow_merge_if_all_discussions_are_resolved),/projects&/projects&post&201():::EXIT
post+projects,only_allow_merge_if_pipeline_succeeds,input.only_allow_merge_if_pipeline_succeeds == return.only_allow_merge_if_pipeline_succeeds,daikon.inv.binary.twoScalar.IntEqual,"(input.only_allow_merge_if_pipeline_succeeds, return.only_allow_merge_if_pipeline_succeeds)",pm.expect(input_only_allow_merge_if_pipeline_succeeds).to.eql(return_only_allow_merge_if_pipeline_succeeds),/projects&/projects&post&201():::EXIT
post+projects,open_issues_count,"return.open_issues_count == return.forks_count
return.open_issues_count <= size(return.tag_list[])","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.open_issues_count, return.forks_count)
(return.open_issues_count, size(return.tag_list[..]))","pm.expect(return_open_issues_count).to.eql(return_forks_count)
pm.expect(return_open_issues_count).to.be.lte(return_tag_list_size_array)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,owner.id,"return.owner.id == return.creator_id
return.owner.id <= return.namespace.id","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.owner.id, return.creator_id)
(return.owner.id, return.namespace.id)","pm.expect(return_owner_id).to.eql(return_creator_id)
pm.expect(return_owner_id).to.be.lte(return_namespace_id)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,owner.name,"return.owner.name == return.namespace.name
return.owner.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(return.owner.name, return.namespace.name)
(return.owner.name, return.name_with_namespace)","pm.expect(return_owner_name).to.eql(return_namespace_name)
pm.expect(return_name_with_namespace.includes(return_owner_name)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,packages_enabled,input.packages_enabled == return.packages_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.packages_enabled, return.packages_enabled)",pm.expect(input_packages_enabled).to.eql(return_packages_enabled),/projects&/projects&post&201():::EXIT
post+projects,path,"input.path == return.path
return.path is a substring of return.path_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(input.path, return.path)
(return.path, return.path_with_namespace)","pm.expect(input_path).to.eql(return_path)
pm.expect(return_path_with_namespace.includes(return_path)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,path_with_namespace,"input.path is a substring of return.path_with_namespace
return.namespace.full_path is a substring of return.path_with_namespace","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(input.path, return.path_with_namespace)
(return.path_with_namespace, return.namespace.full_path)","pm.expect(return_path_with_namespace.includes(input_path)).to.be.true
pm.expect(return_path_with_namespace.includes(return_namespace_full_path)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,permissions,return.permissions == null,daikon.inv.unary.scalar.OneOfScalar,(return.permissions),pm.expect(return_permissions).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,permissions.group_access,return.permissions.group_access == null,daikon.inv.unary.scalar.OneOfScalar,(return.permissions.group_access),pm.expect(return_permissions_group_access).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,permissions.project_access,return.permissions.project_access == null,daikon.inv.unary.scalar.OneOfScalar,(return.permissions.project_access),pm.expect(return_permissions_project_access).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,public_jobs,input.public_builds == return.public_jobs,daikon.inv.binary.twoScalar.IntEqual,"(input.public_builds, return.public_jobs)",pm.expect(input_public_builds).to.eql(return_public_jobs),/projects&/projects&post&201():::EXIT
post+projects,readme_url,input.default_branch is a substring of return.readme_url,daikon.inv.binary.twoString.StdString$SubString,"(input.default_branch, return.readme_url)",pm.expect(return_readme_url.includes(input_default_branch)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,remove_source_branch_after_merge,input.remove_source_branch_after_merge == return.remove_source_branch_after_merge,daikon.inv.binary.twoScalar.IntEqual,"(input.remove_source_branch_after_merge, return.remove_source_branch_after_merge)",pm.expect(input_remove_source_branch_after_merge).to.eql(return_remove_source_branch_after_merge),/projects&/projects&post&201():::EXIT
post+projects,repository_storage,"input.repository_storage == return.repository_storage
return.repository_storage == ""default""
LENGTH(return.repository_storage)==7","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(input.repository_storage, return.repository_storage)
(return.repository_storage)
(return.repository_storage)","pm.expect(input_repository_storage).to.eql(return_repository_storage)
pm.expect([""default""].includes(return_repository_storage)).to.be.true
pm.expect(return_repository_storage).to.have.length(7)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,request_access_enabled,input.request_access_enabled == return.request_access_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.request_access_enabled, return.request_access_enabled)",pm.expect(input_request_access_enabled).to.eql(return_request_access_enabled),/projects&/projects&post&201():::EXIT
post+projects,resolve_outdated_diff_discussions,input.resolve_outdated_diff_discussions == return.resolve_outdated_diff_discussions,daikon.inv.binary.twoScalar.IntEqual,"(input.resolve_outdated_diff_discussions, return.resolve_outdated_diff_discussions)",pm.expect(input_resolve_outdated_diff_discussions).to.eql(return_resolve_outdated_diff_discussions),/projects&/projects&post&201():::EXIT
post+projects,runners_token,LENGTH(return.runners_token)==29,daikon.inv.unary.string.FixedLengthString,(return.runners_token),pm.expect(return_runners_token).to.have.length(29),/projects&/projects&post&201():::EXIT
post+projects,shared_runners_enabled,input.shared_runners_enabled == return.shared_runners_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.shared_runners_enabled, return.shared_runners_enabled)",pm.expect(input_shared_runners_enabled).to.eql(return_shared_runners_enabled),/projects&/projects&post&201():::EXIT
post+projects,shared_with_groups,return.shared_with_groups[] == [],daikon.inv.unary.sequence.OneOfSequence,(return.shared_with_groups[..]),pm.expect([[]].some(value => pm.expect(return_shared_with_groups_array).to.deep.equal(value).that)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,ssh_url_to_repo,return.path_with_namespace is a substring of return.ssh_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.ssh_url_to_repo, return.path_with_namespace)",pm.expect(return_ssh_url_to_repo.includes(return_path_with_namespace)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,statistics,return.statistics == null,daikon.inv.unary.scalar.OneOfScalar,(return.statistics),pm.expect(return_statistics).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,tag_list,size(input.tag_list[]) == size(return.tag_list[]),daikon.inv.binary.twoScalar.IntEqual,"(size(input.tag_list[..]), size(return.tag_list[..]))",pm.expect(input_tag_list_size_array).to.eql(return_tag_list_size_array),/projects&/projects&post&201():::EXIT
post+projects,visibility,"input.visibility == return.visibility
return.visibility one of { ""internal"", ""private"", ""public"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.visibility, return.visibility)
(return.visibility)","pm.expect(input_visibility).to.eql(return_visibility)
pm.expect([""internal"", ""private"", ""public""].includes(return_visibility)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,web_url,"return.web_url is a substring of return.readme_url
return.path_with_namespace is a substring of return.web_url","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return.web_url, return.readme_url)
(return.web_url, return.path_with_namespace)","pm.expect(return_readme_url.includes(return_web_url)).to.be.true
pm.expect(return_web_url.includes(return_path_with_namespace)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects_{id}_repository_commits,author_email,input.author_email == return.author_email,daikon.inv.binary.twoString.StringEqual,"(input.author_email, return.author_email)",pm.expect(input_author_email).to.eql(return_author_email),/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_repository_commits,author_name,input.author_name == return.author_name,daikon.inv.binary.twoString.StringEqual,"(input.author_name, return.author_name)",pm.expect(input_author_name).to.eql(return_author_name),/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_repository_commits,authored_date,"return.authored_date == return.committed_date
return.authored_date == return.created_at
LENGTH(return.authored_date)==29
return.authored_date is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.authored_date, return.committed_date)
(return.authored_date, return.created_at)
(return.authored_date)
(return.authored_date)","pm.expect(return_authored_date).to.eql(return_committed_date)
pm.expect(return_authored_date).to.eql(return_created_at)
pm.expect(return_authored_date).to.have.length(29)
pm.expect(return_authored_date).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT"
post+projects_{id}_repository_commits,committer_email,return.committer_email is Email,daikon.inv.unary.string.IsEmail,(return.committer_email),"pm.expect(return_committer_email).to.match(/^(?:[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*|""(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*"")@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\.)+[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]^[0-9]?|[A-Za-z0-9-]*[A-Za-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/)",/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_repository_commits,id,"return.id == return.last_pipeline.sha
LENGTH(return.id)==40
return.short_id is a substring of return.id
return.id is a substring of return.web_url","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.FixedLengthString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return.id, return.last_pipeline.sha)
(return.id)
(return.id, return.short_id)
(return.id, return.web_url)","pm.expect(return_id).to.eql(return_last_pipeline_sha)
pm.expect(return_id).to.have.length(40)
pm.expect(return_id.includes(return_short_id)).to.be.true
pm.expect(return_web_url.includes(return_id)).to.be.true","/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT"
post+projects_{id}_repository_commits,last_pipeline.ref,input.branch == return.last_pipeline.ref,daikon.inv.binary.twoString.StringEqual,"(input.branch, return.last_pipeline.ref)",pm.expect(input_branch).to.eql(return_last_pipeline_ref),/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_repository_commits,last_pipeline.sha,"LENGTH(return.last_pipeline.sha)==40
return.last_pipeline.sha is a substring of return.web_url","daikon.inv.unary.string.FixedLengthString
daikon.inv.binary.twoString.StdString$SubString","(return.last_pipeline.sha)
(return.last_pipeline.sha, return.web_url)","pm.expect(return_last_pipeline_sha).to.have.length(40)
pm.expect(return_web_url.includes(return_last_pipeline_sha)).to.be.true","/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT"
post+projects_{id}_repository_commits,last_pipeline.status,return.last_pipeline.status == return.status,daikon.inv.binary.twoString.StringEqual,"(return.last_pipeline.status, return.status)",pm.expect(return_last_pipeline_status).to.eql(return_status),/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_repository_commits,message,input.commit_message == return.message,daikon.inv.binary.twoString.StringEqual,"(input.commit_message, return.message)",pm.expect(input_commit_message).to.eql(return_message),/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_repository_commits,parent_ids,"size(input.actions[]) == size(return.parent_ids[])
size(input.actions[]) == size(return.parent_ids[])
All the elements of return.parent_ids[] have LENGTH=40
input.start_sha in return.parent_ids[]","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.stringsequence.SequenceFixedLengthString
daikon.inv.binary.sequenceString.MemberString","(size(input.actions[..]), size(return.parent_ids[..]))
(size(input.actions[..]), size(return.parent_ids[..]))
(return.parent_ids[..])
(input.start_sha, return.parent_ids[..])","pm.expect(input_actions_size_array).to.eql(return_parent_ids_size_array)
pm.expect(input_actions_size_array).to.eql(return_parent_ids_size_array)
pm.expect(return_parent_ids_array.every(element => element.length === 40)).to.be.true
pm.expect(return_parent_ids_array.includes(input_start_sha)).to.be.true","/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT"
post+projects_{id}_repository_commits,short_id,"LENGTH(return.short_id)==8
return.short_id is a substring of return.last_pipeline.sha","daikon.inv.unary.string.FixedLengthString
daikon.inv.binary.twoString.StdString$SubString","(return.short_id)
(return.short_id, return.last_pipeline.sha)","pm.expect(return_short_id).to.have.length(8)
pm.expect(return_last_pipeline_sha.includes(return_short_id)).to.be.true","/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT"
post+projects_{id}_repository_commits,stats.additions,"return.stats.additions <= return.stats.total
return.stats.additions <= size(input.actions[])","daikon.inv.binary.twoScalar.IntLessEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.stats.additions, return.stats.total)
(return.stats.additions, size(input.actions[..]))","pm.expect(return_stats_additions).to.be.lte(return_stats_total)
pm.expect(return_stats_additions).to.be.lte(input_actions_size_array)","/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT"
post+projects_{id}_repository_commits,stats.deletions,"return.stats.deletions >= 0
return.stats.deletions <= return.stats.total","daikon.inv.unary.scalar.LowerBound
daikon.inv.binary.twoScalar.IntLessEqual","(return.stats.deletions)
(return.stats.deletions, return.stats.total)","pm.expect(return_stats_deletions).to.be.at.least(0)
pm.expect(return_stats_deletions).to.be.lte(return_stats_total)","/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT"
post+projects_{id}_repository_commits,stats.total,return.stats.total >= 0,daikon.inv.unary.scalar.LowerBound,(return.stats.total),pm.expect(return_stats_total).to.be.at.least(0),/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_repository_commits,title,input.commit_message == return.title,daikon.inv.binary.twoString.StringEqual,"(input.commit_message, return.title)",pm.expect(input_commit_message).to.eql(return_title),/projects/{id}/repository/commits&/projects/{id}/repository/commits&post&201():::EXIT
post+projects_{id}_statuses_{sha},allow_failure,return.allow_failure == false,daikon.inv.unary.scalar.OneOfScalar,(return.allow_failure),pm.expect(return_allow_failure).to.eql(false),/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},author.avatar_url,"LENGTH(return.author.avatar_url)==113
return.author.avatar_url is Url","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.IsUrl","(return.author.avatar_url)
(return.author.avatar_url)","pm.expect(return_author_avatar_url).to.have.length(113)
pm.expect(return_author_avatar_url).to.match(/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[\w\u00a1-\uffff0-9]+-?)*[\w\u00a1-\uffff0-9]+)(?:\.(?:[\w\u00a1-\uffff0-9]+-)*[\w\u00a1-\uffff0-9]+)*(?:\.(?:[a-zA-Z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/)","/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT"
post+projects_{id}_statuses_{sha},author.state,"return.author.state == ""active""
LENGTH(return.author.state)==6","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.author.state)
(return.author.state)","pm.expect([""active""].includes(return_author_state)).to.be.true
pm.expect(return_author_state).to.have.length(6)","/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT"
post+projects_{id}_statuses_{sha},author.web_url,return.author.username is a substring of return.author.web_url,daikon.inv.binary.twoString.StdString$SubString,"(return.author.web_url, return.author.username)",pm.expect(return_author_web_url.includes(return_author_username)).to.be.true,/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},coverage,return.coverage is Numeric,daikon.inv.unary.string.IsNumeric,(return.coverage),"pm.expect(return_coverage).to.match(/^[+-]{0,1}(0|([0-9](\d*|\d{0,2}(,\d{3})*)))?(\.\d*[0-9])?$/)",/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT"
post+projects_{id}_statuses_{sha},description,input.description == return.description,daikon.inv.binary.twoString.StringEqual,"(input.description, return.description)",pm.expect(input_description).to.eql(return_description),/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},finished_at,"LENGTH(return.finished_at)==24
return.finished_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.finished_at)
(return.finished_at)","pm.expect(return_finished_at).to.have.length(24)
pm.expect(return_finished_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT"
post+projects_{id}_statuses_{sha},id,return.id is Numeric,daikon.inv.unary.string.IsNumeric,(return.id),"pm.expect(return_id).to.match(/^[+-]{0,1}(0|([0-9](\d*|\d{0,2}(,\d{3})*)))?(\.\d*[0-9])?$/)",/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},name,input.name == return.name,daikon.inv.binary.twoString.StringEqual,"(input.name, return.name)",pm.expect(input_name).to.eql(return_name),/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},ref,input.ref == return.ref,daikon.inv.binary.twoString.StringEqual,"(input.ref, return.ref)",pm.expect(input_ref).to.eql(return_ref),/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},sha,"LENGTH(return.sha)==40
input.sha is a substring of return.sha","daikon.inv.unary.string.FixedLengthString
daikon.inv.binary.twoString.StdString$SubString","(return.sha)
(input.sha, return.sha)","pm.expect(return_sha).to.have.length(40)
pm.expect(return_sha.includes(input_sha)).to.be.true","/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT"
post+projects_{id}_statuses_{sha},started_at,"LENGTH(return.started_at)==24
return.started_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.started_at)
(return.started_at)","pm.expect(return_started_at).to.have.length(24)
pm.expect(return_started_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT"
post+projects_{id}_statuses_{sha},status,input.state == return.status,daikon.inv.binary.twoString.StringEqual,"(input.state, return.status)",pm.expect(input_state).to.eql(return_status),/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
post+projects_{id}_statuses_{sha},target_url,input.target_url == return.target_url,daikon.inv.binary.twoString.StringEqual,"(input.target_url, return.target_url)",pm.expect(input_target_url).to.eql(return_target_url),/projects/{id}/statuses/{sha}&/projects/{id}/statuses/{sha}&post&201():::EXIT
