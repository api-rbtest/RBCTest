endpoint,group,invariant,invariantType,variables,postmanAssertion,pptname
get+projects,_links.self,"return._links.self is a substring of return._links.issues
return._links.self is a substring of return._links.merge_requests
return._links.self is a substring of return._links.repo_branches
return._links.self is a substring of return._links.labels
return._links.self is a substring of return._links.events
return._links.self is a substring of return._links.members","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return._links.self, return._links.issues)
(return._links.self, return._links.merge_requests)
(return._links.self, return._links.repo_branches)
(return._links.self, return._links.labels)
(return._links.self, return._links.events)
(return._links.self, return._links.members)","pm.expect(return__links_issues.includes(return__links_self)).to.be.true
pm.expect(return__links_merge_requests.includes(return__links_self)).to.be.true
pm.expect(return__links_repo_branches.includes(return__links_self)).to.be.true
pm.expect(return__links_labels.includes(return__links_self)).to.be.true
pm.expect(return__links_events.includes(return__links_self)).to.be.true
pm.expect(return__links_members.includes(return__links_self)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,archived,input.archived == return.archived,daikon.inv.binary.twoScalar.IntEqual,"(input.archived, return.archived)",pm.expect(input_archived).to.eql(return_archived),/projects&/projects&get&200():::EXIT
get+projects,auto_devops_deploy_strategy,"return.auto_devops_deploy_strategy one of { ""continuous"", ""manual"", ""timed_incremental"" }",daikon.inv.unary.string.OneOfString,(return.auto_devops_deploy_strategy),"pm.expect([""continuous"", ""manual"", ""timed_incremental""].includes(return_auto_devops_deploy_strategy)).to.be.true",/projects&/projects&get&200():::EXIT
get+projects,avatar_url,return.avatar_url is Url,daikon.inv.unary.string.IsUrl,(return.avatar_url),"pm.expect(return_avatar_url).to.match(/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[\w\u00a1-\uffff0-9]+-?)*[\w\u00a1-\uffff0-9]+)(?:\.(?:[\w\u00a1-\uffff0-9]+-)*[\w\u00a1-\uffff0-9]+)*(?:\.(?:[a-zA-Z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/)",/projects&/projects&get&200():::EXIT
get+projects,created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,creator_id,return.creator_id >= 1,daikon.inv.unary.scalar.LowerBound,(return.creator_id),pm.expect(return_creator_id).to.be.at.least(1),/projects&/projects&get&200():::EXIT
get+projects,default_branch,return.default_branch is a substring of return.readme_url,daikon.inv.binary.twoString.StdString$SubString,"(return.default_branch, return.readme_url)",pm.expect(return_readme_url.includes(return_default_branch)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,external_authorization_classification_label,"return.external_authorization_classification_label == """"
LENGTH(return.external_authorization_classification_label)==0","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.external_authorization_classification_label)
(return.external_authorization_classification_label)","pm.expect([""""].includes(return_external_authorization_classification_label)).to.be.true
pm.expect(return_external_authorization_classification_label).to.have.length(0)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,forks_count,return.forks_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.forks_count),pm.expect(return_forks_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,http_url_to_repo,return.web_url is a substring of return.http_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.http_url_to_repo, return.web_url)",pm.expect(return_http_url_to_repo.includes(return_web_url)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,id,"input.id_after < return.id
input.id_before > return.id
return.id > return.star_count
return.id > size(return.tag_list[])","daikon.inv.binary.twoScalar.IntLessThan
daikon.inv.binary.twoScalar.IntGreaterThan
daikon.inv.binary.twoScalar.IntGreaterThan
daikon.inv.binary.twoScalar.IntGreaterThan","(input.id_after, return.id)
(input.id_before, return.id)
(return.id, return.star_count)
(return.id, size(return.tag_list[..]))","pm.expect(input_id_after).to.be.lessThan(return_id)
pm.expect(input_id_before).to.be.greaterThan(return_id)
pm.expect(return_id).to.be.greaterThan(return_star_count)
pm.expect(return_id).to.be.greaterThan(return_tag_list_size_array)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,last_activity_at,"LENGTH(return.last_activity_at)==24
return.last_activity_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.last_activity_at)
(return.last_activity_at)","pm.expect(return_last_activity_at).to.have.length(24)
pm.expect(return_last_activity_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,merge_method,"return.merge_method one of { ""ff"", ""merge"", ""rebase_merge"" }",daikon.inv.unary.string.OneOfString,(return.merge_method),"pm.expect([""ff"", ""merge"", ""rebase_merge""].includes(return_merge_method)).to.be.true",/projects&/projects&get&200():::EXIT
get+projects,name,return.name is a substring of return.name_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.name, return.name_with_namespace)",pm.expect(return_name_with_namespace.includes(return_name)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,name_with_namespace,return.namespace.name is a substring of return.name_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.name_with_namespace, return.namespace.name)",pm.expect(return_name_with_namespace.includes(return_namespace_name)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,namespace.id,return.namespace.id >= 1,daikon.inv.unary.scalar.LowerBound,(return.namespace.id),pm.expect(return_namespace_id).to.be.at.least(1),/projects&/projects&get&200():::EXIT
get+projects,namespace.kind,"return.namespace.kind one of { ""group"", ""user"" }",daikon.inv.unary.string.OneOfString,(return.namespace.kind),"pm.expect([""group"", ""user""].includes(return_namespace_kind)).to.be.true",/projects&/projects&get&200():::EXIT
get+projects,namespace.path,return.namespace.path is a substring of return.namespace.full_path,daikon.inv.binary.twoString.StdString$SubString,"(return.namespace.path, return.namespace.full_path)",pm.expect(return_namespace_full_path.includes(return_namespace_path)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,open_issues_count,return.open_issues_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.open_issues_count),pm.expect(return_open_issues_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,owner.id,return.owner.id >= 1,daikon.inv.unary.scalar.LowerBound,(return.owner.id),pm.expect(return_owner_id).to.be.at.least(1),/projects&/projects&get&200():::EXIT
get+projects,owner.name,"return.owner.name == return.namespace.name
return.owner.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(return.owner.name, return.namespace.name)
(return.owner.name, return.name_with_namespace)","pm.expect(return_owner_name).to.eql(return_namespace_name)
pm.expect(return_name_with_namespace.includes(return_owner_name)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,path,return.path is a substring of return.path_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.path, return.path_with_namespace)",pm.expect(return_path_with_namespace.includes(return_path)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,path_with_namespace,return.namespace.full_path is a substring of return.path_with_namespace,daikon.inv.binary.twoString.StdString$SubString,"(return.path_with_namespace, return.namespace.full_path)",pm.expect(return_path_with_namespace.includes(return_namespace_full_path)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,permissions.group_access.notification_level,return.permissions.group_access.notification_level == 3,daikon.inv.unary.scalar.OneOfScalar,(return.permissions.group_access.notification_level),pm.expect([3].includes(return_permissions_group_access_notification_level)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,permissions.project_access.access_level,return.permissions.project_access.access_level == return.permissions.group_access.access_level,daikon.inv.binary.twoScalar.IntEqual,"(return.permissions.project_access.access_level, return.permissions.group_access.access_level)",pm.expect(return_permissions_project_access_access_level).to.eql(return_permissions_group_access_access_level),/projects&/projects&get&200():::EXIT
get+projects,permissions.project_access.notification_level,"return.permissions.project_access.notification_level == return.permissions.group_access.notification_level
return.permissions.project_access.notification_level == 3","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.OneOfScalar","(return.permissions.project_access.notification_level, return.permissions.group_access.notification_level)
(return.permissions.project_access.notification_level)","pm.expect(return_permissions_project_access_notification_level).to.eql(return_permissions_group_access_notification_level)
pm.expect([3].includes(return_permissions_project_access_notification_level)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,repository_storage,"return.repository_storage == ""default""
LENGTH(return.repository_storage)==7","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.repository_storage)
(return.repository_storage)","pm.expect([""default""].includes(return_repository_storage)).to.be.true
pm.expect(return_repository_storage).to.have.length(7)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,runners_token,LENGTH(return.runners_token)==29,daikon.inv.unary.string.FixedLengthString,(return.runners_token),pm.expect(return_runners_token).to.have.length(29),/projects&/projects&get&200():::EXIT
get+projects,ssh_url_to_repo,return.path_with_namespace is a substring of return.ssh_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.ssh_url_to_repo, return.path_with_namespace)",pm.expect(return_ssh_url_to_repo.includes(return_path_with_namespace)).to.be.true,/projects&/projects&get&200():::EXIT
get+projects,star_count,return.star_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.star_count),pm.expect(return_star_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,statistics.commit_count,return.statistics.commit_count >= 0,daikon.inv.unary.scalar.LowerBound,(return.statistics.commit_count),pm.expect(return_statistics_commit_count).to.be.at.least(0),/projects&/projects&get&200():::EXIT
get+projects,statistics.repository_size,"return.statistics.repository_size >= 0
return.statistics.repository_size >= return.statistics.lfs_objects_size","daikon.inv.unary.scalar.LowerBound
daikon.inv.binary.twoScalar.IntGreaterEqual","(return.statistics.repository_size)
(return.statistics.repository_size, return.statistics.lfs_objects_size)","pm.expect(return_statistics_repository_size).to.be.at.least(0)
pm.expect(return_statistics_repository_size).to.be.at.least(return_statistics_lfs_objects_size)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,statistics.storage_size,"return.statistics.storage_size >= 0
return.statistics.storage_size >= return.statistics.repository_size
return.statistics.storage_size >= return.statistics.wiki_size
return.statistics.storage_size >= return.statistics.lfs_objects_size","daikon.inv.unary.scalar.LowerBound
daikon.inv.binary.twoScalar.IntGreaterEqual
daikon.inv.binary.twoScalar.IntGreaterEqual
daikon.inv.binary.twoScalar.IntGreaterEqual","(return.statistics.storage_size)
(return.statistics.storage_size, return.statistics.repository_size)
(return.statistics.storage_size, return.statistics.wiki_size)
(return.statistics.storage_size, return.statistics.lfs_objects_size)","pm.expect(return_statistics_storage_size).to.be.at.least(0)
pm.expect(return_statistics_storage_size).to.be.at.least(return_statistics_repository_size)
pm.expect(return_statistics_storage_size).to.be.at.least(return_statistics_wiki_size)
pm.expect(return_statistics_storage_size).to.be.at.least(return_statistics_lfs_objects_size)","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,visibility,"input.visibility == return.visibility
return.visibility one of { ""internal"", ""private"", ""public"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.visibility, return.visibility)
(return.visibility)","pm.expect(input_visibility).to.eql(return_visibility)
pm.expect([""internal"", ""private"", ""public""].includes(return_visibility)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects,web_url,"return.web_url is a substring of return.readme_url
return.path_with_namespace is a substring of return.web_url","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return.web_url, return.readme_url)
(return.web_url, return.path_with_namespace)","pm.expect(return_readme_url.includes(return_web_url)).to.be.true
pm.expect(return_web_url.includes(return_path_with_namespace)).to.be.true","/projects&/projects&get&200():::EXIT
/projects&/projects&get&200():::EXIT"
get+projects_{id}_repository_branches,commit.authored_date,"LENGTH(return.commit.authored_date)==29
return.commit.authored_date is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.commit.authored_date)
(return.commit.authored_date)","pm.expect(return_commit_authored_date).to.have.length(29)
pm.expect(return_commit_authored_date).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT"
get+projects_{id}_repository_branches,commit.created_at,"LENGTH(return.commit.created_at)==29
return.commit.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.commit.created_at)
(return.commit.created_at)","pm.expect(return_commit_created_at).to.have.length(29)
pm.expect(return_commit_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT"
get+projects_{id}_repository_branches,commit.id,"LENGTH(return.commit.id)==40
return.commit.short_id is a substring of return.commit.id","daikon.inv.unary.string.FixedLengthString
daikon.inv.binary.twoString.StdString$SubString","(return.commit.id)
(return.commit.id, return.commit.short_id)","pm.expect(return_commit_id).to.have.length(40)
pm.expect(return_commit_id.includes(return_commit_short_id)).to.be.true","/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT"
get+projects_{id}_repository_branches,commit.message,return.commit.title is a substring of return.commit.message,daikon.inv.binary.twoString.StdString$SubString,"(return.commit.message, return.commit.title)",pm.expect(return_commit_message.includes(return_commit_title)).to.be.true,/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
get+projects_{id}_repository_branches,commit.parent_ids,"All the elements of return.commit.parent_ids[] have LENGTH=40
size(return.commit.parent_ids[]) one of { 0, 1, 2 }","daikon.inv.unary.stringsequence.SequenceFixedLengthString
daikon.inv.unary.scalar.OneOfScalar","(return.commit.parent_ids[..])
(size(return.commit.parent_ids[..]))","pm.expect(return_commit_parent_ids_array.every(element => element.length === 40)).to.be.true
pm.expect([0, 1, 2].includes(return_commit_parent_ids_size_array)).to.be.true","/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT"
get+projects_{id}_repository_branches,commit.short_id,LENGTH(return.commit.short_id)==8,daikon.inv.unary.string.FixedLengthString,(return.commit.short_id),pm.expect(return_commit_short_id).to.have.length(8),/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
get+projects_{id}_repository_branches,name,input.search is a substring of return.name,daikon.inv.binary.twoString.StdString$SubString,"(input.search, return.name)",pm.expect(return_name.includes(input_search)).to.be.true,/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
get+projects_{id}_repository_branches,web_url,input.search is a substring of return.web_url,daikon.inv.binary.twoString.StdString$SubString,"(input.search, return.web_url)",pm.expect(return_web_url.includes(input_search)).to.be.true,/projects/{id}/repository/branches&/projects/{id}/repository/branches&get&200():::EXIT
post+projects,_links.self,"return._links.self is a substring of return._links.issues
return._links.self is a substring of return._links.merge_requests
return._links.self is a substring of return._links.repo_branches
return._links.self is a substring of return._links.labels
return._links.self is a substring of return._links.events
return._links.self is a substring of return._links.members","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return._links.self, return._links.issues)
(return._links.self, return._links.merge_requests)
(return._links.self, return._links.repo_branches)
(return._links.self, return._links.labels)
(return._links.self, return._links.events)
(return._links.self, return._links.members)","pm.expect(return__links_issues.includes(return__links_self)).to.be.true
pm.expect(return__links_merge_requests.includes(return__links_self)).to.be.true
pm.expect(return__links_repo_branches.includes(return__links_self)).to.be.true
pm.expect(return__links_labels.includes(return__links_self)).to.be.true
pm.expect(return__links_events.includes(return__links_self)).to.be.true
pm.expect(return__links_members.includes(return__links_self)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,allow_merge_on_skipped_pipeline,input.allow_merge_on_skipped_pipeline == return.allow_merge_on_skipped_pipeline,daikon.inv.binary.twoScalar.IntEqual,"(input.allow_merge_on_skipped_pipeline, return.allow_merge_on_skipped_pipeline)",pm.expect(input_allow_merge_on_skipped_pipeline).to.eql(return_allow_merge_on_skipped_pipeline),/projects&/projects&post&201():::EXIT
post+projects,archived,"return.archived == return.service_desk_enabled
return.archived == false","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.OneOfScalar","(return.archived, return.service_desk_enabled)
(return.archived)","pm.expect(return_archived).to.eql(return_service_desk_enabled)
pm.expect(return_archived).to.eql(false)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,auto_devops_deploy_strategy,"input.auto_devops_deploy_strategy == return.auto_devops_deploy_strategy
return.auto_devops_deploy_strategy one of { ""continuous"", ""manual"", ""timed_incremental"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.auto_devops_deploy_strategy, return.auto_devops_deploy_strategy)
(return.auto_devops_deploy_strategy)","pm.expect(input_auto_devops_deploy_strategy).to.eql(return_auto_devops_deploy_strategy)
pm.expect([""continuous"", ""manual"", ""timed_incremental""].includes(return_auto_devops_deploy_strategy)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,auto_devops_enabled,input.auto_devops_enabled == return.auto_devops_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.auto_devops_enabled, return.auto_devops_enabled)",pm.expect(input_auto_devops_enabled).to.eql(return_auto_devops_enabled),/projects&/projects&post&201():::EXIT
post+projects,autoclose_referenced_issues,input.autoclose_referenced_issues == return.autoclose_referenced_issues,daikon.inv.binary.twoScalar.IntEqual,"(input.autoclose_referenced_issues, return.autoclose_referenced_issues)",pm.expect(input_autoclose_referenced_issues).to.eql(return_autoclose_referenced_issues),/projects&/projects&post&201():::EXIT
post+projects,ci_default_git_depth,return.ci_default_git_depth == 20,daikon.inv.unary.scalar.OneOfScalar,(return.ci_default_git_depth),pm.expect([20].includes(return_ci_default_git_depth)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,ci_forward_deployment_enabled,return.ci_forward_deployment_enabled == true,daikon.inv.unary.scalar.OneOfScalar,(return.ci_forward_deployment_enabled),pm.expect(return_ci_forward_deployment_enabled).to.eql(true),/projects&/projects&post&201():::EXIT
post+projects,container_registry_enabled,input.container_registry_enabled == return.container_registry_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.container_registry_enabled, return.container_registry_enabled)",pm.expect(input_container_registry_enabled).to.eql(return_container_registry_enabled),/projects&/projects&post&201():::EXIT
post+projects,created_at,"LENGTH(return.created_at)==24
return.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.created_at)
(return.created_at)","pm.expect(return_created_at).to.have.length(24)
pm.expect(return_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,creator_id,return.creator_id <= return.namespace.id,daikon.inv.binary.twoScalar.IntLessEqual,"(return.creator_id, return.namespace.id)",pm.expect(return_creator_id).to.be.lte(return_namespace_id),/projects&/projects&post&201():::EXIT
post+projects,default_branch,return.default_branch is a substring of return.readme_url,daikon.inv.binary.twoString.StdString$SubString,"(return.default_branch, return.readme_url)",pm.expect(return_readme_url.includes(return_default_branch)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,description,input.description == return.description,daikon.inv.binary.twoString.StringEqual,"(input.description, return.description)",pm.expect(input_description).to.eql(return_description),/projects&/projects&post&201():::EXIT
post+projects,forks_count,"return.forks_count == return.star_count
return.forks_count == size(return.shared_with_groups[])
return.forks_count == size(return.shared_with_groups[])
return.forks_count <= size(return.tag_list[])","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.forks_count, return.star_count)
(return.forks_count, size(return.shared_with_groups[..]))
(return.forks_count, size(return.shared_with_groups[..]))
(return.forks_count, size(return.tag_list[..]))","pm.expect(return_forks_count).to.eql(return_star_count)
pm.expect(return_forks_count).to.eql(return_shared_with_groups_size_array)
pm.expect(return_forks_count).to.eql(return_shared_with_groups_size_array)
pm.expect(return_forks_count).to.be.lte(return_tag_list_size_array)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,http_url_to_repo,return.web_url is a substring of return.http_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.http_url_to_repo, return.web_url)",pm.expect(return_http_url_to_repo.includes(return_web_url)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,import_status,"return.import_status == ""none""
LENGTH(return.import_status)==4","daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(return.import_status)
(return.import_status)","pm.expect([""none""].includes(return_import_status)).to.be.true
pm.expect(return_import_status).to.have.length(4)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,last_activity_at,"LENGTH(return.last_activity_at)==24
return.last_activity_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.last_activity_at)
(return.last_activity_at)","pm.expect(return_last_activity_at).to.have.length(24)
pm.expect(return_last_activity_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,merge_method,"input.merge_method == return.merge_method
return.merge_method one of { ""ff"", ""merge"", ""rebase_merge"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.merge_method, return.merge_method)
(return.merge_method)","pm.expect(input_merge_method).to.eql(return_merge_method)
pm.expect([""ff"", ""merge"", ""rebase_merge""].includes(return_merge_method)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,name,"input.name == return.name
return.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(input.name, return.name)
(return.name, return.name_with_namespace)","pm.expect(input_name).to.eql(return_name)
pm.expect(return_name_with_namespace.includes(return_name)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,name_with_namespace,"input.name is a substring of return.name_with_namespace
return.namespace.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(input.name, return.name_with_namespace)
(return.name_with_namespace, return.namespace.name)","pm.expect(return_name_with_namespace.includes(input_name)).to.be.true
pm.expect(return_name_with_namespace.includes(return_namespace_name)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,namespace.id,"input.namespace_id == return.namespace.id
return.namespace.id >= 1","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.LowerBound","(input.namespace_id, return.namespace.id)
(return.namespace.id)","pm.expect(input_namespace_id).to.eql(return_namespace_id)
pm.expect(return_namespace_id).to.be.at.least(1)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,namespace.kind,"return.namespace.kind one of { ""group"", ""user"" }",daikon.inv.unary.string.OneOfString,(return.namespace.kind),"pm.expect([""group"", ""user""].includes(return_namespace_kind)).to.be.true",/projects&/projects&post&201():::EXIT
post+projects,namespace.path,return.namespace.path is a substring of return.namespace.full_path,daikon.inv.binary.twoString.StdString$SubString,"(return.namespace.path, return.namespace.full_path)",pm.expect(return_namespace_full_path.includes(return_namespace_path)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,only_allow_merge_if_all_discussions_are_resolved,input.only_allow_merge_if_all_discussions_are_resolved == return.only_allow_merge_if_all_discussions_are_resolved,daikon.inv.binary.twoScalar.IntEqual,"(input.only_allow_merge_if_all_discussions_are_resolved, return.only_allow_merge_if_all_discussions_are_resolved)",pm.expect(input_only_allow_merge_if_all_discussions_are_resolved).to.eql(return_only_allow_merge_if_all_discussions_are_resolved),/projects&/projects&post&201():::EXIT
post+projects,only_allow_merge_if_pipeline_succeeds,input.only_allow_merge_if_pipeline_succeeds == return.only_allow_merge_if_pipeline_succeeds,daikon.inv.binary.twoScalar.IntEqual,"(input.only_allow_merge_if_pipeline_succeeds, return.only_allow_merge_if_pipeline_succeeds)",pm.expect(input_only_allow_merge_if_pipeline_succeeds).to.eql(return_only_allow_merge_if_pipeline_succeeds),/projects&/projects&post&201():::EXIT
post+projects,open_issues_count,"return.open_issues_count == return.forks_count
return.open_issues_count <= size(return.tag_list[])","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.open_issues_count, return.forks_count)
(return.open_issues_count, size(return.tag_list[..]))","pm.expect(return_open_issues_count).to.eql(return_forks_count)
pm.expect(return_open_issues_count).to.be.lte(return_tag_list_size_array)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,owner.id,"return.owner.id == return.creator_id
return.owner.id <= return.namespace.id","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntLessEqual","(return.owner.id, return.creator_id)
(return.owner.id, return.namespace.id)","pm.expect(return_owner_id).to.eql(return_creator_id)
pm.expect(return_owner_id).to.be.lte(return_namespace_id)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,owner.name,"return.owner.name == return.namespace.name
return.owner.name is a substring of return.name_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(return.owner.name, return.namespace.name)
(return.owner.name, return.name_with_namespace)","pm.expect(return_owner_name).to.eql(return_namespace_name)
pm.expect(return_name_with_namespace.includes(return_owner_name)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,packages_enabled,input.packages_enabled == return.packages_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.packages_enabled, return.packages_enabled)",pm.expect(input_packages_enabled).to.eql(return_packages_enabled),/projects&/projects&post&201():::EXIT
post+projects,path,"input.path == return.path
return.path is a substring of return.path_with_namespace","daikon.inv.binary.twoString.StringEqual
daikon.inv.binary.twoString.StdString$SubString","(input.path, return.path)
(return.path, return.path_with_namespace)","pm.expect(input_path).to.eql(return_path)
pm.expect(return_path_with_namespace.includes(return_path)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,path_with_namespace,"input.path is a substring of return.path_with_namespace
return.namespace.full_path is a substring of return.path_with_namespace","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(input.path, return.path_with_namespace)
(return.path_with_namespace, return.namespace.full_path)","pm.expect(return_path_with_namespace.includes(input_path)).to.be.true
pm.expect(return_path_with_namespace.includes(return_namespace_full_path)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,permissions,return.permissions == null,daikon.inv.unary.scalar.OneOfScalar,(return.permissions),pm.expect(return_permissions).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,permissions.group_access,return.permissions.group_access == null,daikon.inv.unary.scalar.OneOfScalar,(return.permissions.group_access),pm.expect(return_permissions_group_access).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,permissions.project_access,return.permissions.project_access == null,daikon.inv.unary.scalar.OneOfScalar,(return.permissions.project_access),pm.expect(return_permissions_project_access).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,public_jobs,input.public_builds == return.public_jobs,daikon.inv.binary.twoScalar.IntEqual,"(input.public_builds, return.public_jobs)",pm.expect(input_public_builds).to.eql(return_public_jobs),/projects&/projects&post&201():::EXIT
post+projects,readme_url,input.default_branch is a substring of return.readme_url,daikon.inv.binary.twoString.StdString$SubString,"(input.default_branch, return.readme_url)",pm.expect(return_readme_url.includes(input_default_branch)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,remove_source_branch_after_merge,input.remove_source_branch_after_merge == return.remove_source_branch_after_merge,daikon.inv.binary.twoScalar.IntEqual,"(input.remove_source_branch_after_merge, return.remove_source_branch_after_merge)",pm.expect(input_remove_source_branch_after_merge).to.eql(return_remove_source_branch_after_merge),/projects&/projects&post&201():::EXIT
post+projects,repository_storage,"input.repository_storage == return.repository_storage
return.repository_storage == ""default""
LENGTH(return.repository_storage)==7","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString
daikon.inv.unary.string.FixedLengthString","(input.repository_storage, return.repository_storage)
(return.repository_storage)
(return.repository_storage)","pm.expect(input_repository_storage).to.eql(return_repository_storage)
pm.expect([""default""].includes(return_repository_storage)).to.be.true
pm.expect(return_repository_storage).to.have.length(7)","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,request_access_enabled,input.request_access_enabled == return.request_access_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.request_access_enabled, return.request_access_enabled)",pm.expect(input_request_access_enabled).to.eql(return_request_access_enabled),/projects&/projects&post&201():::EXIT
post+projects,resolve_outdated_diff_discussions,input.resolve_outdated_diff_discussions == return.resolve_outdated_diff_discussions,daikon.inv.binary.twoScalar.IntEqual,"(input.resolve_outdated_diff_discussions, return.resolve_outdated_diff_discussions)",pm.expect(input_resolve_outdated_diff_discussions).to.eql(return_resolve_outdated_diff_discussions),/projects&/projects&post&201():::EXIT
post+projects,runners_token,LENGTH(return.runners_token)==29,daikon.inv.unary.string.FixedLengthString,(return.runners_token),pm.expect(return_runners_token).to.have.length(29),/projects&/projects&post&201():::EXIT
post+projects,shared_runners_enabled,input.shared_runners_enabled == return.shared_runners_enabled,daikon.inv.binary.twoScalar.IntEqual,"(input.shared_runners_enabled, return.shared_runners_enabled)",pm.expect(input_shared_runners_enabled).to.eql(return_shared_runners_enabled),/projects&/projects&post&201():::EXIT
post+projects,shared_with_groups,return.shared_with_groups[] == [],daikon.inv.unary.sequence.OneOfSequence,(return.shared_with_groups[..]),pm.expect([[]].some(value => pm.expect(return_shared_with_groups_array).to.deep.equal(value).that)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,ssh_url_to_repo,return.path_with_namespace is a substring of return.ssh_url_to_repo,daikon.inv.binary.twoString.StdString$SubString,"(return.ssh_url_to_repo, return.path_with_namespace)",pm.expect(return_ssh_url_to_repo.includes(return_path_with_namespace)).to.be.true,/projects&/projects&post&201():::EXIT
post+projects,statistics,return.statistics == null,daikon.inv.unary.scalar.OneOfScalar,(return.statistics),pm.expect(return_statistics).to.be.null,/projects&/projects&post&201():::EXIT
post+projects,tag_list,size(input.tag_list[]) == size(return.tag_list[]),daikon.inv.binary.twoScalar.IntEqual,"(size(input.tag_list[..]), size(return.tag_list[..]))",pm.expect(input_tag_list_size_array).to.eql(return_tag_list_size_array),/projects&/projects&post&201():::EXIT
post+projects,visibility,"input.visibility == return.visibility
return.visibility one of { ""internal"", ""private"", ""public"" }","daikon.inv.binary.twoString.StringEqual
daikon.inv.unary.string.OneOfString","(input.visibility, return.visibility)
(return.visibility)","pm.expect(input_visibility).to.eql(return_visibility)
pm.expect([""internal"", ""private"", ""public""].includes(return_visibility)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects,web_url,"return.web_url is a substring of return.readme_url
return.path_with_namespace is a substring of return.web_url","daikon.inv.binary.twoString.StdString$SubString
daikon.inv.binary.twoString.StdString$SubString","(return.web_url, return.readme_url)
(return.web_url, return.path_with_namespace)","pm.expect(return_readme_url.includes(return_web_url)).to.be.true
pm.expect(return_web_url.includes(return_path_with_namespace)).to.be.true","/projects&/projects&post&201():::EXIT
/projects&/projects&post&201():::EXIT"
post+projects_{id}_protected_branches,allow_force_push,input.allow_force_push == return.allow_force_push,daikon.inv.binary.twoScalar.IntEqual,"(input.allow_force_push, return.allow_force_push)",pm.expect(input_allow_force_push).to.eql(return_allow_force_push),/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT
post+projects_{id}_protected_branches,code_owner_approval_required,return.code_owner_approval_required == false,daikon.inv.unary.scalar.OneOfScalar,(return.code_owner_approval_required),pm.expect(return_code_owner_approval_required).to.eql(false),/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT
post+projects_{id}_protected_branches,merge_access_levels,"size(return.merge_access_levels[]) == size(return.push_access_levels[])
size(return.merge_access_levels[]) == size(return.push_access_levels[])
size(return.merge_access_levels[]) == size(return.unprotect_access_levels[])
size(return.merge_access_levels[]) == size(return.unprotect_access_levels[])
size(return.merge_access_levels[]) == 1","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.OneOfScalar","(size(return.merge_access_levels[..]), size(return.push_access_levels[..]))
(size(return.merge_access_levels[..]), size(return.push_access_levels[..]))
(size(return.merge_access_levels[..]), size(return.unprotect_access_levels[..]))
(size(return.merge_access_levels[..]), size(return.unprotect_access_levels[..]))
(size(return.merge_access_levels[..]))","pm.expect(return_merge_access_levels_size_array).to.eql(return_push_access_levels_size_array)
pm.expect(return_merge_access_levels_size_array).to.eql(return_push_access_levels_size_array)
pm.expect(return_merge_access_levels_size_array).to.eql(return_unprotect_access_levels_size_array)
pm.expect(return_merge_access_levels_size_array).to.eql(return_unprotect_access_levels_size_array)
pm.expect([1].includes(return_merge_access_levels_size_array)).to.be.true","/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT
/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT
/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT
/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT
/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT"
post+projects_{id}_protected_branches,merge_access_levels.access_level,return.access_level >= 0,daikon.inv.unary.scalar.LowerBound,(return.access_level),pm.expect(return_access_level).to.be.at.least(0),/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201&merge_access_levels():::EXIT
post+projects_{id}_protected_branches,merge_access_levels.access_level_description,"return.access_level_description one of { ""Developers + Maintainers"", ""Maintainers"", ""No one"" }",daikon.inv.unary.string.OneOfString,(return.access_level_description),"pm.expect([""Developers + Maintainers"", ""Maintainers"", ""No one""].includes(return_access_level_description)).to.be.true",/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201&merge_access_levels():::EXIT
post+projects_{id}_protected_branches,name,input.name == return.name,daikon.inv.binary.twoString.StringEqual,"(input.name, return.name)",pm.expect(input_name).to.eql(return_name),/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201():::EXIT
post+projects_{id}_protected_branches,push_access_levels.access_level,return.access_level >= 0,daikon.inv.unary.scalar.LowerBound,(return.access_level),pm.expect(return_access_level).to.be.at.least(0),/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201&push_access_levels():::EXIT
post+projects_{id}_protected_branches,push_access_levels.access_level_description,"return.access_level_description one of { ""Developers + Maintainers"", ""Maintainers"", ""No one"" }",daikon.inv.unary.string.OneOfString,(return.access_level_description),"pm.expect([""Developers + Maintainers"", ""Maintainers"", ""No one""].includes(return_access_level_description)).to.be.true",/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201&push_access_levels():::EXIT
post+projects_{id}_protected_branches,unprotect_access_levels.access_level,return.access_level >= 0,daikon.inv.unary.scalar.LowerBound,(return.access_level),pm.expect(return_access_level).to.be.at.least(0),/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201&unprotect_access_levels():::EXIT
post+projects_{id}_protected_branches,unprotect_access_levels.access_level_description,"return.access_level_description one of { ""Developers + Maintainers"", ""Maintainers"", ""No one"" }",daikon.inv.unary.string.OneOfString,(return.access_level_description),"pm.expect([""Developers + Maintainers"", ""Maintainers"", ""No one""].includes(return_access_level_description)).to.be.true",/projects/{id}/protected_branches&/projects/{id}/protected_branches&post&201&unprotect_access_levels():::EXIT
post+projects_{id}_repository_branches,can_push,return.can_push == true,daikon.inv.unary.scalar.OneOfScalar,(return.can_push),pm.expect(return_can_push).to.eql(true),/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
post+projects_{id}_repository_branches,commit.author_email,return.commit.author_email is Email,daikon.inv.unary.string.IsEmail,(return.commit.author_email),"pm.expect(return_commit_author_email).to.match(/^(?:[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*|""(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*"")@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\.)+[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]^[0-9]?|[A-Za-z0-9-]*[A-Za-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/)",/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
post+projects_{id}_repository_branches,commit.authored_date,"LENGTH(return.commit.authored_date)==29
return.commit.authored_date is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.commit.authored_date)
(return.commit.authored_date)","pm.expect(return_commit_authored_date).to.have.length(29)
pm.expect(return_commit_authored_date).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT"
post+projects_{id}_repository_branches,commit.committer_email,return.commit.committer_email is Email,daikon.inv.unary.string.IsEmail,(return.commit.committer_email),"pm.expect(return_commit_committer_email).to.match(/^(?:[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*|""(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*"")@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\.)+[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]^[0-9]?|[A-Za-z0-9-]*[A-Za-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/)",/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
post+projects_{id}_repository_branches,commit.created_at,"LENGTH(return.commit.created_at)==29
return.commit.created_at is Timestamp. Format: YYYY-MM-DDTHH:MM:SS.mmZ (Miliseconds are optional)","daikon.inv.unary.string.FixedLengthString
daikon.inv.unary.string.dates.IsTimestampYYYYMMHHThhmmssmm","(return.commit.created_at)
(return.commit.created_at)","pm.expect(return_commit_created_at).to.have.length(29)
pm.expect(return_commit_created_at).to.match(/^[0-9]{4}-((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(0[469]|11)-(0[1-9]|[12][0-9]|30)|(02)-(0[1-9]|[12][0-9]))T(0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\.[0-9]{3}){0,1}(Z|(-|\+)(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])$/)","/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT"
post+projects_{id}_repository_branches,commit.id,"LENGTH(return.commit.id)==40
return.commit.short_id is a substring of return.commit.id","daikon.inv.unary.string.FixedLengthString
daikon.inv.binary.twoString.StdString$SubString","(return.commit.id)
(return.commit.id, return.commit.short_id)","pm.expect(return_commit_id).to.have.length(40)
pm.expect(return_commit_id.includes(return_commit_short_id)).to.be.true","/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT"
post+projects_{id}_repository_branches,commit.message,return.commit.title is a substring of return.commit.message,daikon.inv.binary.twoString.StdString$SubString,"(return.commit.message, return.commit.title)",pm.expect(return_commit_message.includes(return_commit_title)).to.be.true,/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
post+projects_{id}_repository_branches,commit.parent_ids,"All the elements of return.commit.parent_ids[] have LENGTH=40
size(return.commit.parent_ids[]) one of { 0, 1, 2 }","daikon.inv.unary.stringsequence.SequenceFixedLengthString
daikon.inv.unary.scalar.OneOfScalar","(return.commit.parent_ids[..])
(size(return.commit.parent_ids[..]))","pm.expect(return_commit_parent_ids_array.every(element => element.length === 40)).to.be.true
pm.expect([0, 1, 2].includes(return_commit_parent_ids_size_array)).to.be.true","/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT"
post+projects_{id}_repository_branches,commit.short_id,LENGTH(return.commit.short_id)==8,daikon.inv.unary.string.FixedLengthString,(return.commit.short_id),pm.expect(return_commit_short_id).to.have.length(8),/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
post+projects_{id}_repository_branches,default,"return.default == return.developers_can_merge
return.default == return.developers_can_push
return.default == false","daikon.inv.binary.twoScalar.IntEqual
daikon.inv.binary.twoScalar.IntEqual
daikon.inv.unary.scalar.OneOfScalar","(return.default, return.developers_can_merge)
(return.default, return.developers_can_push)
(return.default)","pm.expect(return_default).to.eql(return_developers_can_merge)
pm.expect(return_default).to.eql(return_developers_can_push)
pm.expect(return_default).to.eql(false)","/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT"
post+projects_{id}_repository_branches,name,input.branch == return.name,daikon.inv.binary.twoString.StringEqual,"(input.branch, return.name)",pm.expect(input_branch).to.eql(return_name),/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
post+projects_{id}_repository_branches,web_url,input.branch is a substring of return.web_url,daikon.inv.binary.twoString.StdString$SubString,"(input.branch, return.web_url)",pm.expect(return_web_url.includes(input_branch)).to.be.true,/projects/{id}/repository/branches&/projects/{id}/repository/branches&post&201():::EXIT
